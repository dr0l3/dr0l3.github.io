---
published: false
---
Whenever category theory is mentioned it is often surrounded with a healthy amount of skepticism. It is my theory that most of this skepticism stems from the fact that its rarely explained why one should bother with category theory. 

At its heart category theory is about converting things. Or rather when you convert A into B what properties of A can you expect B to also have. For example, if I sort a list of A’s and convert them into B’s and then sort the B’s are the elements sorted in the same order? To concretize; I can represent weekdays as both a string (the weekday name) and an integer (monday = 1 , tuesday = 2, etc.). I can also convert freely between the two representations, but when i sort the integers i get a different ordering than when i sort the strings (using the natural ordering. i can of course define my own order that sort them in the same way).

Converting things, why is that important? By itself converting things is not that important. But together with faithful and minimal representations of state that preserve as many properties as possible things change. Why is that important? Primarily because it leads to

- Easier to read code
- Fewer bugs
- Smaller test surface
- Less code that is easier to maintain
- Properly modularized and reusable code

Basically everything that is important in software :)

Sounds nice, but what exactly is a “minimal and faithful representation”? And how does it preserve properties? And why does it make my code easier to read and write? Let’s go back to our weekday example and ponder how we could represent weekdays in a program, specifically what type we would like to use for it. We already have two candidates; strings and ints. Lets try and compare the two. 

If we choose ints then monday will be 1, tuesday will be 2 etc. The numbers 1 through 7 will be meaningful days. But what about 0, 99 and -5? One way of doing it would be to just say that all numbers that are not 1 through 7 would be monday. Now all ints are defined as weekdays and it is always easy to know what day a given integer represents. Another choice would be use the modulo operator to get the weekday, in this case 8 would be monday, 9 would be tuesday etc. This has the advantage that we can now use arithmetic to figure out what a given day is. Say today is tuesday (2) and we want to know what they 17 days from now is. We can then do 2 + 17 % 7 = 5 (friday). Can't do that trick reliably if 0 is considered a monday. We would then have to check that the day is between 1 and 7 before we do the calculation.

If instead we went with strings then each day would simply be the english representation of that day, monday is monday, tuesday is tuesday etc. But what about the string ‘tusday’? Or the string ‘akjslkdj’? We could do the same trick as with ints and say that all strings that are not valid days are just monday. I guess it works for ‘akjslkdj’, but makes very little sense for ‘tusday’. So now we need a measure of how close a string is to a given day to handle “non-sensical” cases. Also it seems we can't really to arithmetic. The concept of “tuesday” + 5 is not really defined.

For the sake of completeness lets try representing weekdays using booleans. Clearly this is not gonna work. We could choose true to be weekdays and false to be weekends. We could choose true to be monday and false to be any other day. Regardless of how we make this choice we don't have enough information to store weekdays in a single boolean. 

In reality you should probably define an enum with each weekday when trying to represent the weekdays. 

None of the options considered above were very good fits for representing weekdays. But even if all of the options were bad, they were not equally bad. Booleans were clearly the worst as we were simply not able to store enough information in a single boolean to represent the concept of weekdays. Booleans are not a faithful representation of weekdays. The two remaining types could faithfully represent weekdays, but one preserved the concept of order and the ability to perform arithmetic if we chose the right way of mapping integers to weekdays. This could be useful.There is of course nothing stopping us from writing a function such that we can sort strings as weekdays and perform arithmetic on them and such. In fact an elegant implementation of such a function would be to CONVERT the string to an int and use the fundamental properties of ints followed by CONVERTING the int back to a string. We just stumbled upon our first usage of category theory. Once you open your eyes to it it is everywhere. This is why category theory is important. The problem of selecting proper types to represent our concepts and extending our types with behavior leveraging already existing code is what software development is all about, It is in fact more or less all we do. When done right it oftens saves lots of development time because you leverage fundamental properties of already existing types rather than trying to invent the wheel every time. When done wrong it oftentimes means wasting lots of time compensating for your bad choices by writing functions that are difficult to implement and hard to explain (for example the “what day is ‘tusday’?”-problem from above or iterating x times over a list of strings to figure out what day x days from now is). Having a big arsenal of types and a good understanding of their properties means you can write significantly less code. Being good at this vastly simplifies our jobs in terms of making clean concise code that is easy to test and reason about. It is the 20% that completes 80% of the job.

We never got around to define what it means for something to be minimal representation of something. So let’s do that. Booleans as we saw did not contain enough information to represent weekdays. That is because there is only 2 values of booleans but 7 different weekdays. Both ints and strings have vastly more than 7 values and can thus represent weekdays. Both ints and strings are bigger types than booleans. Java integers are 32 bit long and can thus contain 4294967296 (2^32) different values. Strings can take an infinite amount of values so string is the bigger type of strings and ints. Among ints, strings and booleans ints is the minimal faithful representation of weekdays. Of course a smaller one would be to define the weekday enum with its 7 obvious inhabitants. In fact any enum with 7 values will suffice. In fact any type with 7 values will suffice. They are all equivalent and all of them can be converted into ints and then sorted and used in arithmetic. All else being equal one should always prefer the smallest type to represent a concept if for no other reason then because it takes up less space in memory.

I hope that i have shed some light on what category theory brings to the table. In my mind category theory is for programmers what physics is for construction engineers. A big topic with _some_ useful elements that everyone should know.
